/* Calculates the texture to apply to terrain.
 *
 * XYX:vector*3  location on sphere
 * LONGITUDE, LATITUDE, BEARING, AZIMUTH camera position
 * RADIUS        normalised radius of planet
 * SEALEVEL      sealevel delta from geoid
 * SEA(XYZ)      returns sealevel at this point
 * TERRAIN(XYZ)  returns real terrain height
 * GEOID(XYZ)    returns geoid height
 * PERLIN(XYZ)   some perlin noise
 * MULTIFRACTAL(XYZ, freq, laq, oct) multifractal noise
 *
 * Returns:
 * 
 * [u, v]        u/v coordinates to pass to Povray
 *
 * All distances are kilometres.
 */

let max(x: real, y: real): real =
	if (x < y) then y else x;

let stockheight = TERRAIN(XYZ);
let water = SEA(XYZ);
let slope = SLOPE(XYZ);
let height = stockheight - water;

[height, slope]

/*
let easecurve(x) =
	(x*x) / (x*x + (1-x)*(1-x));

let blend(x, lo1, hi1, hi2, lo2) =
	if (x < lo1) then 0
	else if (x > lo2) then 0
	else if (x < hi1) then
		easecurve((x-lo1) / (hi1-lo1))
	else if (x > hi2) then
		easecurve((lo2-x) / (lo2-hi2))
	else
		1;

let blend0hi(x, lo, hi) =
	if (x < lo) then 1
	else if (x < hi) then
		1 - easecurve((x-lo) / (hi-lo))
	else
		0;

let SEABED = 0.0;
let SAND = 0.1;
let LOWROCKS = 0.2;
let SCRUB = 0.3;
let FIELDS = 0.4;
let HIGHSCRUB = 0.5;
let HIGHROCKS = 0.6;

let seabed = blend(height, -11, -10, -0.010, 0.010);
let sand = blend(height, -0.010, -0.005, 0.000, 0.005);
let scrub = blend(height, 0.000, 0.005, 1, 1.5);

//seabed*SEABED + sand*SAND + scrub*SCRUB
blend0hi(height, -0.500, 0.000)

//clip(0, PERLIN(XYZ)/2 + 0.5, 1)
*/
